{"ast":null,"code":"/*!\n * VERSION: 1.9.1\n * DATE: 2018-05-30\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nimport { _gsScope } from \"./TweenLite.js\";\n\nvar _doc = (_gsScope.document || {}).documentElement,\n    _window = _gsScope,\n    _max = function (element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim,\n      body = document.body;\n  return element === _window || element === _doc || element === body ? Math.max(_doc[scroll], body[scroll]) - (_window[\"inner\" + dim] || _doc[client] || body[client]) : element[scroll] - element[\"offset\" + dim];\n},\n    _unwrapElement = function (value) {\n  if (typeof value === \"string\") {\n    value = TweenLite.selector(value);\n  }\n\n  if (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {\n    value = value[0];\n  }\n\n  return value === _window || value.nodeType && value.style ? value : null;\n},\n    _buildGetter = function (e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else if (_doc[p] != null) {\n      e = _doc;\n    } else {\n      e = document.body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _getOffset = function (element, container) {\n  var rect = _unwrapElement(element).getBoundingClientRect(),\n      b = document.body,\n      isRoot = !container || container === _window || container === b,\n      cRect = isRoot ? {\n    top: _doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0),\n    left: _doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n  /*\tPREVIOUS\n  var rect = _unwrapElement(element).getBoundingClientRect(),\n  \tisRoot = (!container || container === _window || container === document.body),\n  \tcRect = (isRoot ? _doc : container).getBoundingClientRect(),\n  \toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n  if (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n  \toffsets.x += _buildGetter(container, \"x\")();\n  \toffsets.y += _buildGetter(container, \"y\")();\n  }\n  return offsets;\n  */\n},\n    _parseVal = function (value, target, axis) {\n  var type = typeof value;\n  return !isNaN(value) ? parseFloat(value) : type === \"number\" || type === \"string\" && value.charAt(1) === \"=\" ? value : value === \"max\" ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);\n},\n    ScrollToPlugin = _gsScope._gsDefine.plugin({\n  propName: \"scrollTo\",\n  API: 2,\n  global: true,\n  version: \"1.9.1\",\n  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n  init: function (target, value, tween) {\n    this._wdw = target === _window;\n    this._target = target;\n    this._tween = tween;\n\n    if (typeof value !== \"object\") {\n      value = {\n        y: value\n      }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n\n      if (typeof value.y === \"string\" && value.y !== \"max\" && value.y.charAt(1) !== \"=\") {\n        value.x = value.y;\n      }\n    } else if (value.nodeType) {\n      value = {\n        y: value,\n        x: value\n      };\n    }\n\n    this.vars = value;\n    this._autoKill = value.autoKill !== false;\n    this.getX = _buildGetter(target, \"x\");\n    this.getY = _buildGetter(target, \"y\");\n    this.x = this.xPrev = this.getX();\n    this.y = this.yPrev = this.getY();\n\n    if (value.x != null) {\n      this._addTween(this, \"x\", this.x, _parseVal(value.x, target, \"x\") - (value.offsetX || 0), \"scrollTo_x\", true);\n\n      this._overwriteProps.push(\"scrollTo_x\");\n    } else {\n      this.skipX = true;\n    }\n\n    if (value.y != null) {\n      this._addTween(this, \"y\", this.y, _parseVal(value.y, target, \"y\") - (value.offsetY || 0), \"scrollTo_y\", true);\n\n      this._overwriteProps.push(\"scrollTo_y\");\n    } else {\n      this.skipY = true;\n    }\n\n    return true;\n  },\n  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n  set: function (v) {\n    this._super.setRatio.call(this, v);\n\n    var x = this._wdw || !this.skipX ? this.getX() : this.xPrev,\n        y = this._wdw || !this.skipY ? this.getY() : this.yPrev,\n        yDif = y - this.yPrev,\n        xDif = x - this.xPrev,\n        threshold = ScrollToPlugin.autoKillThreshold;\n\n    if (this.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      this.x = 0;\n    }\n\n    if (this.y < 0) {\n      this.y = 0;\n    }\n\n    if (this._autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, \"x\")) {\n        this.skipX = true; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, \"y\")) {\n        this.skipY = true; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (this.skipX && this.skipY) {\n        this._tween.kill();\n\n        if (this.vars.onAutoKill) {\n          this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);\n        }\n      }\n    }\n\n    if (this._wdw) {\n      _window.scrollTo(!this.skipX ? this.x : x, !this.skipY ? this.y : y);\n    } else {\n      if (!this.skipY) {\n        this._target.scrollTop = this.y;\n      }\n\n      if (!this.skipX) {\n        this._target.scrollLeft = this.x;\n      }\n    }\n\n    this.xPrev = this.x;\n    this.yPrev = this.y;\n  }\n}),\n    p = ScrollToPlugin.prototype;\n\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\nScrollToPlugin.autoKillThreshold = 7;\n\np._kill = function (lookup) {\n  if (lookup.scrollTo_x) {\n    this.skipX = true;\n  }\n\n  if (lookup.scrollTo_y) {\n    this.skipY = true;\n  }\n\n  return this._super._kill.call(this, lookup);\n};\n\nexport { ScrollToPlugin, ScrollToPlugin as default };","map":null,"metadata":{},"sourceType":"module"}