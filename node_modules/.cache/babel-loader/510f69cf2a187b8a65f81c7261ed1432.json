{"ast":null,"code":"/*!\n * VERSION: 0.2.2\n * DATE: 2018-05-30\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nimport { _gsScope } from \"./TweenLite.js\";\n\nvar _numExp = /(\\d|\\.)+/g,\n    _ColorFilter,\n    _ColorMatrixFilter,\n    _colorProps = [\"redMultiplier\", \"greenMultiplier\", \"blueMultiplier\", \"alphaMultiplier\", \"redOffset\", \"greenOffset\", \"blueOffset\", \"alphaOffset\"],\n    _colorLookup = {\n  aqua: [0, 255, 255],\n  lime: [0, 255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, 255],\n  navy: [0, 0, 128],\n  white: [255, 255, 255],\n  fuchsia: [255, 0, 255],\n  olive: [128, 128, 0],\n  yellow: [255, 255, 0],\n  orange: [255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [255, 0, 0],\n  pink: [255, 192, 203],\n  cyan: [0, 255, 255],\n  transparent: [255, 255, 255, 0]\n},\n    _parseColor = function (color) {\n  if (color === \"\" || color == null || color === \"none\") {\n    return _colorLookup.transparent;\n  } else if (_colorLookup[color]) {\n    return _colorLookup[color];\n  } else if (typeof color === \"number\") {\n    return [color >> 16, color >> 8 & 255, color & 255];\n  } else if (color.charAt(0) === \"#\") {\n    if (color.length === 4) {\n      //for shorthand like #9F0\n      color = \"#\" + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2) + color.charAt(3) + color.charAt(3);\n    }\n\n    color = parseInt(color.substr(1), 16);\n    return [color >> 16, color >> 8 & 255, color & 255];\n  }\n\n  return color.match(_numExp) || _colorLookup.transparent;\n},\n    _parseColorFilter = function (t, v, pg) {\n  if (!_ColorFilter) {\n    _ColorFilter = _gsScope.ColorFilter || _gsScope.createjs.ColorFilter;\n\n    if (!_ColorFilter) {\n      throw \"EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.\";\n    }\n  }\n\n  var filters = t.filters || [],\n      i = filters.length,\n      c,\n      s,\n      e,\n      a,\n      p;\n\n  while (--i > -1) {\n    if (filters[i] instanceof _ColorFilter) {\n      s = filters[i];\n      break;\n    }\n  }\n\n  if (!s) {\n    s = new _ColorFilter();\n    filters.push(s);\n    t.filters = filters;\n  }\n\n  e = s.clone();\n\n  if (v.tint != null) {\n    c = _parseColor(v.tint);\n    a = v.tintAmount != null ? Number(v.tintAmount) : 1;\n    e.redOffset = Number(c[0]) * a;\n    e.greenOffset = Number(c[1]) * a;\n    e.blueOffset = Number(c[2]) * a;\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;\n  } else {\n    for (p in v) {\n      if (p !== \"exposure\") if (p !== \"brightness\") {\n        e[p] = Number(v[p]);\n      }\n    }\n  }\n\n  if (v.exposure != null) {\n    e.redOffset = e.greenOffset = e.blueOffset = 255 * (Number(v.exposure) - 1);\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;\n  } else if (v.brightness != null) {\n    a = Number(v.brightness) - 1;\n    e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);\n  }\n\n  i = 8;\n\n  while (--i > -1) {\n    p = _colorProps[i];\n\n    if (s[p] !== e[p]) {\n      pg._addTween(s, p, s[p], e[p], \"easel_colorFilter\");\n    }\n  }\n\n  pg._overwriteProps.push(\"easel_colorFilter\");\n\n  if (!t.cacheID) {\n    throw \"EaselPlugin warning: for filters to display in EaselJS, you must call the object's cache() method first. \" + t;\n  }\n},\n    _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n    _lumR = 0.212671,\n    _lumG = 0.715160,\n    _lumB = 0.072169,\n    _applyMatrix = function (m, m2) {\n  if (!(m instanceof Array) || !(m2 instanceof Array)) {\n    return m2;\n  }\n\n  var temp = [],\n      i = 0,\n      z = 0,\n      y,\n      x;\n\n  for (y = 0; y < 4; y++) {\n    for (x = 0; x < 5; x++) {\n      z = x === 4 ? m[i + 4] : 0;\n      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n    }\n\n    i += 5;\n  }\n\n  return temp;\n},\n    _setSaturation = function (m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  var inv = 1 - n,\n      r = inv * _lumR,\n      g = inv * _lumG,\n      b = inv * _lumB;\n  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _colorize = function (m, color, amount) {\n  if (isNaN(amount)) {\n    amount = 1;\n  }\n\n  var c = _parseColor(color),\n      r = c[0] / 255,\n      g = c[1] / 255,\n      b = c[2] / 255,\n      inv = 1 - amount;\n\n  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _setHue = function (m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  n *= Math.PI / 180;\n  var c = Math.cos(n),\n      s = Math.sin(n);\n  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);\n},\n    _setContrast = function (m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  n += 0.01;\n  return _applyMatrix([n, 0, 0, 0, 128 * (1 - n), 0, n, 0, 0, 128 * (1 - n), 0, 0, n, 0, 128 * (1 - n), 0, 0, 0, 1, 0], m);\n},\n    _parseColorMatrixFilter = function (t, v, pg) {\n  if (!_ColorMatrixFilter) {\n    _ColorMatrixFilter = _gsScope.ColorMatrixFilter || _gsScope.createjs.ColorMatrixFilter;\n\n    if (!_ColorMatrixFilter) {\n      throw \"EaselPlugin error: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.\";\n    }\n  }\n\n  var filters = t.filters || [],\n      i = filters.length,\n      matrix,\n      startMatrix,\n      s;\n\n  while (--i > -1) {\n    if (filters[i] instanceof _ColorMatrixFilter) {\n      s = filters[i];\n      break;\n    }\n  }\n\n  if (!s) {\n    s = new _ColorMatrixFilter(_idMatrix.slice());\n    filters.push(s);\n    t.filters = filters;\n  }\n\n  startMatrix = s.matrix;\n  matrix = _idMatrix.slice();\n\n  if (v.colorize != null) {\n    matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));\n  }\n\n  if (v.contrast != null) {\n    matrix = _setContrast(matrix, Number(v.contrast));\n  }\n\n  if (v.hue != null) {\n    matrix = _setHue(matrix, Number(v.hue));\n  }\n\n  if (v.saturation != null) {\n    matrix = _setSaturation(matrix, Number(v.saturation));\n  }\n\n  i = matrix.length;\n\n  while (--i > -1) {\n    if (matrix[i] !== startMatrix[i]) {\n      pg._addTween(startMatrix, i, startMatrix[i], matrix[i], \"easel_colorMatrixFilter\");\n    }\n  }\n\n  pg._overwriteProps.push(\"easel_colorMatrixFilter\");\n\n  if (!t.cacheID) {\n    throw \"EaselPlugin warning: for filters to display in EaselJS, you must call the object's cache() method first. \" + t;\n  }\n\n  pg._matrix = startMatrix;\n};\n\nvar EaselPlugin = _gsScope._gsDefine.plugin({\n  propName: \"easel\",\n  priority: -1,\n  version: \"0.2.2\",\n  API: 2,\n  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n  init: function (target, value, tween, index) {\n    this._target = target;\n    var p, pt, tint, colorMatrix, end, labels, i;\n\n    for (p in value) {\n      end = value[p];\n\n      if (typeof end === \"function\") {\n        end = end(index, target);\n      }\n\n      if (p === \"colorFilter\" || p === \"tint\" || p === \"tintAmount\" || p === \"exposure\" || p === \"brightness\") {\n        if (!tint) {\n          _parseColorFilter(target, value.colorFilter || value, this);\n\n          tint = true;\n        }\n      } else if (p === \"saturation\" || p === \"contrast\" || p === \"hue\" || p === \"colorize\" || p === \"colorizeAmount\") {\n        if (!colorMatrix) {\n          _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);\n\n          colorMatrix = true;\n        }\n      } else if (p === \"frame\") {\n        this._firstPT = pt = {\n          _next: this._firstPT,\n          t: target,\n          p: \"gotoAndStop\",\n          s: target.currentFrame,\n          f: true,\n          n: \"frame\",\n          pr: 0,\n          type: 0,\n          m: Math.round\n        };\n\n        if (typeof end === \"string\" && end.charAt(1) !== \"=\" && (labels = target.labels)) {\n          for (i = 0; i < labels.length; i++) {\n            if (labels[i].label === end) {\n              end = labels[i].position;\n            }\n          }\n        }\n\n        pt.c = typeof end === \"number\" ? end - pt.s : parseFloat((end + \"\").split(\"=\").join(\"\"));\n\n        if (pt._next) {\n          pt._next._prev = pt;\n        }\n      } else if (target[p] != null) {\n        this._firstPT = pt = {\n          _next: this._firstPT,\n          t: target,\n          p: p,\n          f: typeof target[p] === \"function\",\n          n: p,\n          pr: 0,\n          type: 0\n        };\n        pt.s = !pt.f ? parseFloat(target[p]) : target[p.indexOf(\"set\") || typeof target[\"get\" + p.substr(3)] !== \"function\" ? p : \"get\" + p.substr(3)]();\n        pt.c = typeof end === \"number\" ? end - pt.s : typeof end === \"string\" ? parseFloat(end.split(\"=\").join(\"\")) : 0;\n\n        if (pt._next) {\n          pt._next._prev = pt;\n        }\n      }\n    }\n\n    return true;\n  },\n  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n  set: function (v) {\n    var pt = this._firstPT,\n        min = 0.000001,\n        val;\n\n    while (pt) {\n      val = pt.c * v + pt.s;\n\n      if (pt.m) {\n        val = pt.m(val, pt.t);\n      } else if (val < min && val > -min) {\n        val = 0;\n      }\n\n      if (pt.f) {\n        pt.t[pt.p](val);\n      } else {\n        pt.t[pt.p] = val;\n      }\n\n      pt = pt._next;\n    }\n\n    if (this._target.cacheID) {\n      this._target.updateCache();\n    }\n  }\n});\n\nexport { EaselPlugin, EaselPlugin as default };","map":null,"metadata":{},"sourceType":"module"}